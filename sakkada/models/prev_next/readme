Previous and next element selectors for model instance.
Allow to use specified queryset or custom ordering, else use default ordering.
Mixin work by adding ordering by pk for uniqueness, if it not exist,
and specific filtering by ordered fields.

Functionality added:
-------------------
 *  "_get_current_ordering" method,
    params: queryset instance
    return ordering for specified queryset
 *  "_get_next_or_previous_by_order" method,
    params: order_by=None, queryset=None, cachename=None,
            is_next=True, force=False, as_queryset=False
    - custom "order_by" and "queryset" can be passed via params
    - "cachename" changes internal cachename param, require when used twice
        (or more) with different queryset or/and ordering,
    - caching will be disabled if as_queryset=True or force="nocache",
    - if force is True, update current "cachename".
    return next object if "is_next" else prev object,
        if "as_queryset" - return tuple(queryset, filter, ordering)
 *  "get_next_by_order" method,
    alias to _get_next_or_previous_by_order(is_next=True, **kwargs)
 *  "get_prev_by_order" method,
    alias to _get_next_or_previous_by_order(is_next=False, **kwargs)

Installation:
------------
 *  Install "django-sakkada"
 *  Import "from sakkada.models.prev_next.PrevNextModel"
 *  Set "PrevNextModel" as a class/subclass of your model
 *  Call methods "get_next_by_order" and "get_prev_by_order"
    on model instance with required params

Example usage:
-------------

model code:
--------------------------------------------------------------------------------
from django.db import models
from sakkada.models.prev_next import PrevNextModel


class SomeModel(PrevNextModel, models.Model)
    sort = models.IntegerField(default=500)
    date = models.DateTimeField(blank=True, null=True)

view code:
--------------------------------------------------------------------------------
queryset = SomeModel.objects.filter(some_filter).order_by(*some_order_by)[0:1]
object = get_object_or_404(queryset)

# get next on default ordering and filtering
next = object.get_next_by_order()

# get prev on current ordering and filtering (current queryset)
prev = object.get_prev_by_order(queryset=queryset)

# get prev on custom ordering (cachename must be set to avoid cache names
#   clashing, or force must be in (True, 'nocache') to disable cache at all)
prev = object.get_prev_by_order(order_by=some_other_order_by,
                                cachename='some_name')

# get prev on custom queryset and return queryset
qs = SomeModel.objects.filter(some_other_filter).order_by(*some_other_order_by)
queryset = object.get_prev_by_order(queryset=qs, as_queryset=True)

# get prev on default ordering and filtering, update cache
prev = object.get_prev_by_order(force=True)

# get next on default ordering and filtering, no cache
next = object.get_next_by_order(force=True)

# get next on default ordering and filtering, alternative cachename
next = object.get_next_by_order(cachename='some_other_name')

template code:
--------------------------------------------------------------------------------
{% if object.get_prev_by_order %}
<a class="previous-link" href="{{ object.get_prev_by_order.get_absolute_url }}">Previous article</a>
{% endif %}
{# note: second call of get_prev_by_order is cached by default, also you can use "with" tag #}
